"use client";
import { ChatUI } from "@/features/chat/components/chat-ui";
import { useParams } from "next/navigation";
import { Suspense, useState, useEffect, useRef } from "react";
import { Skeleton } from "@/components/ui/skeleton";
import { Chats, ChatMembers } from "@/features/chat/type";
import { Button } from "@/components/ui/button";
import { MessageCircle } from "lucide-react";
import { chatApi } from "@/features/chat/api";
import { useRealtimeMessages } from "@/hooks/use-realtime";

export default function ChatPage() {
  const params = useParams();
  const workspaceId = params.workspaceId as string;
  const [selectedChat, setSelectedChat] = useState<Chats & { members?: ChatMembers[] } | null>(null);
  const [memberId, setMemberId] = useState<string>("");
  const [chats, setChats] = useState<(Chats & { members?: ChatMembers[] })[]>([]);
  const [messages, setMessages] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isChatsLoading, setIsChatsLoading] = useState(true);
  const [isSyncing, setIsSyncing] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [workspaceName, setWorkspaceName] = useState<string>("");
  const [isInitializing, setIsInitializing] = useState(false);
  const [syncNotification, setSyncNotification] = useState<string | null>(null);
  const [realtimeStatus, setRealtimeStatus] = useState<string | null>(null);
  const [newMessageNotification, setNewMessageNotification] = useState<string | null>(null);
  const notificationAudioRef = useRef<HTMLAudioElement | null>(null);
  const documentTitle = useRef<string>(typeof window !== 'undefined' ? document.title : '');
  const isFocused = useRef<boolean>(true);
  const messageProcessorRef = useRef<((newMessage: any) => void) | null>(null);

  // L·∫Øng nghe s·ª± ki·ªán focus v√† blur c·ªßa c·ª≠a s·ªï
  useEffect(() => {
    // Ch·ªâ ch·∫°y ·ªü ph√≠a client
    if (typeof window !== 'undefined') {
      // L∆∞u title ban ƒë·∫ßu
      documentTitle.current = document.title;
      
      // T·∫°o element audio ƒë·ªÉ ph√°t √¢m thanh th√¥ng b√°o
      const audio = new Audio("/notification.mp3");
      notificationAudioRef.current = audio;
      
      const handleFocus = () => {
        isFocused.current = true;
        // Kh√¥i ph·ª•c ti√™u ƒë·ªÅ khi focus v√†o trang
        document.title = documentTitle.current;
      };
      
      const handleBlur = () => {
        isFocused.current = false;
      };
      
      window.addEventListener('focus', handleFocus);
      window.addEventListener('blur', handleBlur);
      
      return () => {
        window.removeEventListener('focus', handleFocus);
        window.removeEventListener('blur', handleBlur);
      };
    }
  }, []);

  // ƒê·ªãnh nghƒ©a message processor callback m·ªôt l·∫ßn
  useEffect(() => {
    messageProcessorRef.current = (newMessage) => {
      console.log("üîî Nh·∫≠n tin nh·∫Øn m·ªõi qua Realtime:", newMessage);
      
      // Ki·ªÉm tra xem tin nh·∫Øn m·ªõi c√≥ ph·∫£i ƒë√£ c√≥ trong danh s√°ch kh√¥ng
      // S·ª≠ d·ª•ng h√†m callback ƒë·ªÉ ƒë·∫£m b·∫£o truy c·∫≠p state messages m·ªõi nh·∫•t
      setMessages((prevMessages) => {
        // Ki·ªÉm tra xem tin nh·∫Øn ƒë√£ t·ªìn t·∫°i ch∆∞a b·∫±ng ID
        if (prevMessages.some((msg) => msg.$id === newMessage.$id)) {
          console.log(`‚è≠Ô∏è B·ªè qua tin nh·∫Øn ƒë√£ c√≥: ${newMessage.$id}`);
          return prevMessages;
        }
        
        console.log(`‚úÖ Th√™m tin nh·∫Øn m·ªõi v√†o danh s√°ch: ${newMessage.$id}`);
        
        // Ki·ªÉm tra xem tin nh·∫Øn c√≥ ph·∫£i c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i kh√¥ng
        const isFromCurrentUser = newMessage.memberId === memberId;
        
        if (!isFromCurrentUser) {
          // Hi·ªÉn th·ªã th√¥ng b√°o khi c√≥ tin nh·∫Øn m·ªõi t·ª´ ng∆∞·ªùi kh√°c
          const senderName = newMessage.senderName || 'Ai ƒë√≥';
          setNewMessageNotification(`Tin nh·∫Øn m·ªõi t·ª´ ${senderName}`);
          
          // Ph√°t √¢m thanh th√¥ng b√°o
          if (notificationAudioRef.current) {
            notificationAudioRef.current.play().catch(e => console.log("Kh√¥ng th·ªÉ ph√°t √¢m thanh: ", e));
          }
          
          // Thay ƒë·ªïi ti√™u ƒë·ªÅ trang n·∫øu ng∆∞·ªùi d√πng kh√¥ng ·ªü tab n√†y
          if (!isFocused.current && typeof document !== 'undefined') {
            document.title = `(1) Tin nh·∫Øn m·ªõi - ${documentTitle.current}`;
          }
          
          // ·∫®n th√¥ng b√°o sau 5 gi√¢y
          setTimeout(() => {
            setNewMessageNotification(null);
          }, 5000);
        }
        
        // B·ªï sung th√¥ng tin ng∆∞·ªùi g·ª≠i n·∫øu c√≥
        let enrichedMessage = { ...newMessage };
        
        // N·∫øu c√≥ t√™n ng∆∞·ªùi g·ª≠i t·ª´ realtime, s·ª≠ d·ª•ng n√≥
        if (newMessage.senderName) {
          console.log(`üë§ Tin nh·∫Øn t·ª´: ${newMessage.senderName}`);
        }
        
        // Th√™m tin nh·∫Øn m·ªõi v√†o cu·ªëi danh s√°ch (th·ª© t·ª± tƒÉng d·∫ßn theo th·ªùi gian)
        const updatedMessages = [...prevMessages, enrichedMessage];
        
        // ƒê·∫£m b·∫£o tin nh·∫Øn ƒë∆∞·ª£c s·∫Øp x·∫øp theo th·ªùi gian
        return updatedMessages.sort((a, b) => {
          const timeA = new Date(a.CreatedAt || a.$createdAt).getTime();
          const timeB = new Date(b.CreatedAt || b.$createdAt).getTime();
          return timeA - timeB;
        });
      });
      
      // Scroll xu·ªëng d∆∞·ªõi c√πng khi c√≥ tin nh·∫Øn m·ªõi
      if (typeof window !== 'undefined') {
        setTimeout(() => {
          const messagesEndElement = document.getElementById('messages-end');
          if (messagesEndElement) {
            messagesEndElement.scrollIntoView({ behavior: 'smooth' });
          }
        }, 100);
      }
    };
  }, [memberId]);

  // S·ª≠ d·ª•ng hook realtime ƒë·ªÉ nh·∫≠n tin nh·∫Øn m·ªõi - lu√¥n g·ªçi v·ªõi callback wrapper
  const { isConnected } = useRealtimeMessages(
    selectedChat?.$id || null,
    (newMessage) => {
      if (messageProcessorRef.current) {
        messageProcessorRef.current(newMessage);
      }
    }
  );

  // Hi·ªÉn th·ªã tr·∫°ng th√°i realtime khi k·∫øt n·ªëi thay ƒë·ªïi
  useEffect(() => {
    if (isConnected && selectedChat) {
      setRealtimeStatus("Realtime ƒë√£ k·∫øt n·ªëi");
      // ·∫®n th√¥ng b√°o sau 3 gi√¢y
      const timer = setTimeout(() => {
        setRealtimeStatus(null);
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [isConnected, selectedChat]);

  // Fetch member ID
  useEffect(() => {
    if (!workspaceId) return;

    const fetchMemberId = async () => {
      try {
        const response = await fetch(`/api/members/me?workspaceId=${workspaceId}`);
        
        if (response.status === 404) {
          // User is not a member of this workspace
          setError("You are not a member of this workspace. Please join the workspace to access chat.");
          setIsLoading(false);
          return;
        }
        
        if (!response.ok) {
          throw new Error(`Failed to fetch member: ${response.status}`);
        }
        
        const data = await response.json();
        if (data.data) {
          setMemberId(data.data.$id);
          // L·∫•y t√™n workspace t·ª´ member data n·∫øu c√≥
          if (data.data.workspaceName) {
            setWorkspaceName(data.data.workspaceName);
          }
        } else {
          throw new Error("No member data received");
        }
      } catch (error) {
        console.error("Error fetching member:", error);
        setError(`Could not get member information: ${error instanceof Error ? error.message : 'Unknown error'}`);
      } finally {
        setIsLoading(false);
      }
    };

    fetchMemberId();
  }, [workspaceId]);

  // Fetch chats
  useEffect(() => {
    if (!workspaceId || isInitializing) return;

    const fetchChats = async () => {
      try {
        const response = await fetch(`/api/chats?workspaceId=${workspaceId}`);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch chats: ${response.status}`);
        }
        
        const data = await response.json();
        if (data.data && data.data.documents) {
          // Ki·ªÉm tra c√≥ nh√≥m chat n√†o kh√¥ng
          const hasGroupChat = data.data.documents.some(
            (chat: Chats) => chat.isGroup === true
          );
          
          if (!hasGroupChat && memberId) {
            // N·∫øu kh√¥ng c√≥ nh√≥m chat v√† ƒë√£ c√≥ memberId, t·∫°o m·ªôt nh√≥m chat m·∫∑c ƒë·ªãnh
            setIsInitializing(true);
            try {
              // L·∫•y th√¥ng tin workspace ƒë·ªÉ l·∫•y t√™n ch√≠nh x√°c
              const wsResponse = await fetch(`/api/workspaces/${workspaceId}`);
              
              let chatName = "Nh√≥m chung";
              
              if (wsResponse.ok) {
                const workspaceData = await wsResponse.json();
                if (workspaceData?.data?.name) {
                  chatName = workspaceData.data.name;
                }
              } else {
                console.error("Kh√¥ng th·ªÉ l·∫•y th√¥ng tin workspace");
              }
              
              // T·∫°o m·ªôt nh√≥m chat m·ªõi
              const newChat = await chatApi.createChat({
                workspaceId,
                name: chatName,
                isGroup: true
              });
              
              if (newChat.data) {
                try {
                  // ƒê·ªìng b·ªô t·∫•t c·∫£ th√†nh vi√™n v√†o nh√≥m chat m·ªõi
                  const syncResult = await chatApi.syncMembers(newChat.data.$id, workspaceId);
                  console.log('Sync result:', syncResult);
                  
                  // L·∫•y l·∫°i chat v·ªõi th√†nh vi√™n m·ªõi
                  const updatedChatResponse = await fetch(`/api/chats/${newChat.data.$id}`);
                  if (updatedChatResponse.ok) {
                    const updatedChatData = await updatedChatResponse.json();
                    if (updatedChatData?.data) {
                      // Thay th·∫ø chat m·ªõi b·∫±ng phi√™n b·∫£n c√≥ members
                      data.data.documents = data.data.documents.filter((c: any) => c.$id !== newChat.data.$id);
                      data.data.documents.push(updatedChatData.data);
                    }
                  }
                } catch (syncError) {
                  console.error("Error syncing members:", syncError);
                }
              }
            } catch (error) {
              console.error("Error creating default chat:", error);
            } finally {
              setIsInitializing(false);
            }
          }
          
          setChats(data.data.documents);
          
          // N·∫øu c√≥ chat v√† ch∆∞a ch·ªçn chat n√†o, ch·ªçn chat ƒë·∫ßu ti√™n
          if (data.data.documents.length > 0 && !selectedChat) {
            // ∆Øu ti√™n ch·ªçn nh√≥m chat (group chat)
            const defaultGroupChat = data.data.documents.find(
              (chat: Chats) => chat.isGroup === true
            );
            
            if (defaultGroupChat) {
              setSelectedChat(defaultGroupChat);
            } else if (data.data.documents.length > 0) {
              setSelectedChat(data.data.documents[0]);
            }
          }
        }
      } catch (error) {
        setError(`Could not load chats: ${error instanceof Error ? error.message : 'Unknown error'}`);
      } finally {
        setIsChatsLoading(false);
      }
    };

    fetchChats();
  }, [workspaceId, memberId, isInitializing, selectedChat]);

  // Fetch messages when a chat is selected
  useEffect(() => {
    if (!selectedChat?.$id) {
      setMessages([]);
      return;
    }

    const fetchMessages = async () => {
      try {
        const response = await fetch(`/api/chats/${selectedChat.$id}/messages`);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch messages: ${response.status}`);
        }
        
        const data = await response.json();
        if (data.data && data.data.documents) {
          // S·∫Øp x·∫øp tin nh·∫Øn theo th·ª© t·ª± tƒÉng d·∫ßn th·ªùi gian (tin nh·∫Øn c≈© nh·∫•t l√™n tr√™n)
          const sortedMessages = [...data.data.documents].sort((a, b) => {
            const timeA = new Date(a.CreatedAt || a.$createdAt).getTime();
            const timeB = new Date(b.CreatedAt || b.$createdAt).getTime();
            return timeA - timeB;
          });
          setMessages(sortedMessages);
        }
      } catch (error) {
        console.error(`Could not load messages: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    };

    fetchMessages();
  }, [selectedChat?.$id]);

  const handleSelectChat = (chat: Chats & { members?: ChatMembers[] }) => {
    setSelectedChat(chat);
  };

  const handleSyncMembers = async () => {
    if (!selectedChat?.$id || isSyncing) return;
    
    setIsSyncing(true);
    setSyncNotification(null);
    try {
      const response = await chatApi.syncMembers(selectedChat.$id, workspaceId);
      
      if (!response.data) {
        throw new Error("Failed to sync members");
      }
      
      setSyncNotification(response.data.message || "ƒê√£ ƒë·ªìng b·ªô th√†nh vi√™n.");
      
      const chatsData = await chatApi.getChats(workspaceId);
      
      if (chatsData?.data?.documents) {
        setChats(chatsData.data.documents);
        
        const updatedSelectedChat = chatsData.data.documents.find(
          (chat: Chats) => chat.$id === selectedChat.$id
        );
        
        if (updatedSelectedChat) {
          setSelectedChat(updatedSelectedChat);
        }
      }
      
      setTimeout(() => {
        setSyncNotification(null);
      }, 5000);
    } catch (error) {
      console.error("Error syncing members:", error);
      setError(`Failed to sync members: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsSyncing(false);
    }
  };

  const handleSendMessage = async (content: string, file?: File) => {
    if (!selectedChat?.$id || (!content.trim() && !file)) return;
    
    setIsSending(true);
    
    // T·∫°o ID t·∫°m th·ªùi v·ªõi th·ªùi gian ƒë·ªÉ ƒë·∫£m b·∫£o duy nh·∫•t
    const tempId = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // T·∫°o t·∫°m m·ªôt tin nh·∫Øn ƒë·ªÉ hi·ªÉn th·ªã ngay l·∫≠p t·ª©c
    const tempMessage = {
      $id: tempId,
      memberId,
      chatsId: selectedChat.$id,
      content: content,
      CreatedAt: new Date().toISOString(),
      $createdAt: new Date().toISOString(),
      $updatedAt: new Date().toISOString(),
      // Th√™m t√™n ng∆∞·ªùi g·ª≠i ƒë·ªÉ hi·ªÉn th·ªã ngay l·∫≠p t·ª©c
      senderName: "B·∫°n"
    };
    
    // Th√™m tin nh·∫Øn t·∫°m th·ªùi v√†o danh s√°ch ngay l·∫≠p t·ª©c ƒë·ªÉ UX nhanh h∆°n
    setMessages((prevMessages) => {
      const updatedMessages = [...prevMessages, tempMessage];
      
      // ƒê·∫£m b·∫£o tin nh·∫Øn ƒë∆∞·ª£c s·∫Øp x·∫øp theo th·ªùi gian
      return updatedMessages.sort((a, b) => {
        const timeA = new Date(a.CreatedAt || a.$createdAt).getTime();
        const timeB = new Date(b.CreatedAt || b.$createdAt).getTime();
        return timeA - timeB;
      });
    });
    
    // Scroll to newest message
    if (typeof window !== 'undefined') {
      setTimeout(() => {
        const messagesEndElement = document.getElementById('messages-end');
        if (messagesEndElement) {
          messagesEndElement.scrollIntoView({ behavior: 'smooth' });
        }
      }, 100);
    }
    
    try {
      // Ch·ªâ g·ª≠i tin nh·∫Øn, kh√¥ng c·∫≠p nh·∫≠t th√†nh vi√™n
      let messageResponse;
      
      if (file) {
        // Handle file upload
        const formData = new FormData();
        formData.append('file', file);
        formData.append('chatsId', selectedChat.$id);
        formData.append('memberId', memberId);
        
        messageResponse = await fetch('/api/chats/upload', {
          method: 'POST',
          body: formData
        });
      } else {
        // G·ª≠i tin nh·∫Øn vƒÉn b·∫£n
        const response = await fetch(`/api/chats/${selectedChat.$id}/messages`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            memberId,
            content,
            chatsId: selectedChat.$id,
          })
        });
        
        messageResponse = response;
      }
      
      if (!messageResponse.ok) {
        throw new Error(`Failed to send message: ${messageResponse.status}`);
      }
      
      const data = await messageResponse.json();
      
      if (data.data) {
        console.log("‚úÖ Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c g·ª≠i:", data.data);
        
        // Thay th·∫ø tin nh·∫Øn t·∫°m th·ªùi b·∫±ng tin nh·∫Øn th·∫≠t t·ª´ server
        setMessages((prevMessages) => {
          // T·∫°o m·∫£ng m·ªõi kh√¥ng bao g·ªìm tin nh·∫Øn t·∫°m th·ªùi
          const filteredMessages = prevMessages.filter(msg => msg.$id !== tempId);
          
          // Ki·ªÉm tra xem tin nh·∫Øn t·ª´ server ƒë√£ t·ªìn t·∫°i trong danh s√°ch ch∆∞a
          const messageExists = filteredMessages.some(msg => msg.$id === data.data.$id);
          
          // N·∫øu ch∆∞a t·ªìn t·∫°i, th√™m v√†o
          if (!messageExists) {
            const updatedMessages = [...filteredMessages, data.data];
            // ƒê·∫£m b·∫£o tin nh·∫Øn ƒë∆∞·ª£c s·∫Øp x·∫øp theo th·ªùi gian
            return updatedMessages.sort((a, b) => {
              const timeA = new Date(a.CreatedAt || a.$createdAt).getTime();
              const timeB = new Date(b.CreatedAt || b.$createdAt).getTime();
              return timeA - timeB;
            });
          }
          
          return filteredMessages;
        });
      }
    } catch (error) {
      console.error("‚ùå L·ªói khi g·ª≠i tin nh·∫Øn:", error);
      
      // N·∫øu l·ªói, x√≥a tin nh·∫Øn t·∫°m
      setMessages((prevMessages) => 
        prevMessages.filter(msg => msg.$id !== tempId)
      );
      
      // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói
      alert("Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.");
    } finally {
      setIsSending(false);
    }
  };

  const handleRetry = () => {
    setError(null);
    setIsLoading(true);
    setIsChatsLoading(true);
    
    // Trigger reloading data by forcing the useEffects to run again
    if (workspaceId) {
      // The member ID and chats fetching logic is in useEffects
      // Just reset the states, and the effects will handle the fetching
      setMemberId("");
      setChats([]);
    }
  };

  // Function to handle joining workspace
  const handleJoinWorkspace = async () => {
    // This is a placeholder for joining workspace functionality
    // You would need to implement this based on your workspace join process
    try {
      alert("Please implement workspace joining functionality");
      // Example implementation would be something like:
      // await fetch(`/api/workspaces/${workspaceId}/join`, {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({ code: 'invite-code-here' }),
      // });
      // Then retry loading
      handleRetry();
    } catch (error) {
      console.error("Error joining workspace:", error);
      setError("Failed to join workspace. Please try again.");
    }
  };

  return (
    <div className="p-4 lg:p-6 space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold tracking-tight">Chat {workspaceName && `- ${workspaceName}`}</h1>
        <div className="flex items-center gap-2">
          {newMessageNotification && (
            <div className="text-sm text-yellow-600 dark:text-yellow-500 bg-yellow-100 dark:bg-yellow-900/30 px-3 py-1 rounded-full flex items-center animate-pulse">
              <span className="h-2 w-2 rounded-full bg-yellow-500 mr-2"></span>
              {newMessageNotification}
            </div>
          )}
          {realtimeStatus && (
            <div className="text-sm text-green-500 bg-green-50 dark:bg-green-900/20 px-3 py-1 rounded-full flex items-center">
              <span className="animate-pulse h-2 w-2 rounded-full bg-green-500 mr-2"></span>
              {realtimeStatus}
            </div>
          )}
        </div>
      </div>
      
      <Suspense fallback={<ChatSkeleton />}>
        {error && error.includes("not a member") ? (
          <div className="h-full flex flex-col items-center justify-center p-8">
            <div className="mb-6 p-4 rounded-full bg-muted">
              <MessageCircle className="h-8 w-8 text-primary" />
            </div>
            <h2 className="text-2xl font-semibold mb-4">Join Workspace to Chat</h2>
            <p className="text-muted-foreground text-center max-w-md mb-6">
              You need to be a member of this workspace to access the chat feature.
            </p>
            <div className="flex gap-4">
              <Button onClick={handleJoinWorkspace} className="gap-2">
                Join Workspace
              </Button>
              <Button variant="outline" onClick={() => window.history.back()}>
                Go Back
              </Button>
            </div>
          </div>
        ) : (
          <ChatUI 
            workspaceId={workspaceId}
            selectedChat={selectedChat}
            memberId={memberId}
            chats={chats}
            isLoading={isLoading || isInitializing}
            isChatsLoading={isChatsLoading}
            isSyncing={isSyncing}
            error={error}
            syncNotification={syncNotification}
            onSelectChat={handleSelectChat}
            onSyncMembers={handleSyncMembers}
            onRetry={handleRetry}
            onSendMessage={handleSendMessage}
            messages={messages}
            isSending={isSending}
            isRealtimeConnected={isConnected}
          />
        )}
      </Suspense>
    </div>
  );
}

// Skeleton loader for chat interface
function ChatSkeleton() {
  return (
    <div className="flex h-[calc(100vh-120px)] gap-4">
      <Skeleton className="w-80 h-full" />
      <Skeleton className="flex-1 h-full" />
    </div>
  );
}